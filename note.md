# CPP-Module 00

### CPP-Module 00 keywords
namespaces, classes, member functions, stdio streams, initialization lists, static, const, and some other basic stuff

### namespaces
- 名前空間は「名前の衝突を避けるための仕組み」。C の struct に近い。
- 名前空間は、関連する名前（関数、クラス、変数など）をグループ化する機能。`namespace`キーワードで定義する。
- 使い方：
	- 定義：`namespace 名前空間名 { /* 内容 */ }`
	- アクセス：`名前空間名::要素名`
	- 簡易アクセス：`using namespace 名前空間名;`で名前空間全体、または`using 名前空間名::要素名;`で特定要素をインポート。ただし課題では禁止されている。理由はライブラリに存在する関数であるのか、または、自分で定義した関数であるかが分からなくなるため。
- 参考: [C++ Namespaces](https://en.cppreference.com/w/cpp/language/namespace),[Qiitaの記事](https://qiita.com/_EnumHack/items/430da105a541f9ecd774)

### classes (クラス)
- クラスは「データとその操作をまとめた型」。C++の基本的なデータ構造。
- クラスは、データ（メンバ変数）とそのデータを操作する関数（メンバ関数）を一緒に定義する。
- Cのstructとの違いまとめ
  - struct: データ袋。誰でも書ける＝壊しやすい。初期化/後始末は人間まかせ。
class: データ＋正しい使い方をひとかたまりにし、初期化と後始末を自動化。誤用をコンパイル時に防げる。
- 定義方法：
  ```cpp
  class クラス名 {
  public: // アクセス修飾子
	  // メンバ変数
	  int メンバ変数名;

	  // コンストラクタ
	  クラス名() : メンバ変数名(初期値) {}

	  // メンバ関数
	  void 関数名() {
		  // 処理内容
	  }
  };
  ```
- アクセス修飾子は、クラスの外からのアクセス制御を行うために使用される。
- public/private: クラスの中でアクセス範囲を切り替えるワード
  - public: 外部からアクセス可能。外から見える・使える。
  - private: クラスの外からはアクセス不可。外からは見えない・使えない。
- 直接いじれると壊しやすい。ありえない値を入れられてしまう。
- クラスのインスタンスは、`クラス名 変数名;`で作成される。

### member function (メンバ関数)
- メンバ関数は、クラスの中で定義される関数で、クラスのインスタンスに対して操作を行う。
- メンバ関数は、クラスのデータにアクセスできる。
- 定義方法：
  ```cpp
  void クラス名::関数名() {
	  // 処理内容
  }
  ```

### stdio streams (標準入出力ストリーム)
- C++では、標準入出力を行うために`iostream`ライブラリを使用する。
- 標準入出力ストリームは、`std::cout`（出力）と`std::cin`（入力）を使用する。
- `std::cout`は、標準出力ストリームで、コンソールに文字列を出力するために使用される。
- `std::cin`は、標準入力ストリームで、コンソールから文字列を入力するために使用される。
- 例:
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
	  cout << "Hello, World!" << endl; // 出力
	  int x;
	  cin >> x; // 入力
	  return 0;
  }
  ```
- CとC++の違い:
  - C: stdio.h の FILE* と関数（printf/scanf など）
  - C++: iostream のストリームオブジェクト（std::cin/std::cout/std::cerr）と演算子 << >> を使用
  - 併用すると、C++のストリームとCの関数が混在し、予期せぬ動作を引き起こす可能性があるため、注意が必要。参考: [iostream と stdio の併用](https://docs.oracle.com/cd/E19957-01/805-7889/z4000016dc65a/index.html)

### initialization lists (初期化リスト)
- 初期化リストは、クラスのコンストラクタでメンバ変数を初期化するための方法。
- メンバ/基底を「生成と同時に」所望の値で初期化して無駄をなくす
- 定義方法：
  ```cpp
  class クラス名 {
  public:
	  int メンバ変数名;

	  // コンストラクタ
	  クラス名(int 引数) : メンバ変数名(引数) {}
  };
  ```

### static
- 目的: 可視性の制御（内部リンケージ）、共有状態（クラス変数）、静的記憶域期間
- 分類:
  - ファイルスコープ: `static int g;`（翻訳単位内のみ）。C++では `namespace { ... }` も可
  - クラスの静的メンバ変数: 全インスタンスで共有。宣言はクラス内、定義は.cppの1か所
  - クラスの静的メンバ関数: `this` を持たない。インスタンスなしで呼べる
  - 関数内 static: 初回一度だけ初期化。以降の呼び出しでも値を保持
- Cとの関係:
  - 共通: ファイルスコープstatic=内部リンケージ、関数内static=静的記憶域期間
  - 相違: C++はクラスのstaticがある／匿名名前空間でも内部リンケージを表現可
- C++98メモ:
  - 非constの静的データメンバはクラス内初期化不可 → `.cpp` で `T Class::m = ...;`
  - `static const int` などの整数型はクラス内で値可（ODR使用時は.cpp定義が必要な場合あり）

### const
- 目的: 読み取り専用にして誤変更を防ぐ（const-correctness）
- 基本: `const int n = 10;` 初期化後は変更不可
- 関数引数: `void f(const std::string& s);` → コピー回避＋書き換え禁止
- メンバ関数: `T get() const;` → 状態を変えない関数に付ける（const オブジェクトからは const 関数のみ呼べる）
- ポインタ:
  - `const int* p`  = 指す先が const（*p 書けない）
  - `int* const p`  = ポインタ自体が const（p 付け替え不可）
  - `const int* const p` = 両方 const
- 参照: `const T&` で安全に借りる・一時の延命
- C++の違い: 名前空間スコープの `const` は内部リンケージがデフォ。共有したいなら `extern const` をヘッダに、定義は .cpp に置く


## Makefile

### 依存関係自動生成 (-MMD -MP -MF)

- 目的：ヘッダーファイルの変更を検出し、再コンパイルを行う。
- メリット：
  - 手動で依存関係を管理する必要がなくなる。具体的に言うと、ソースファイルがインクルードするヘッダーファイルの変更を自動的に検出し、必要なファイルのみを再コンパイルすることができる。
  - ヘッダーファイルの変更に応じて自動的に再コンパイルされる。
  - ビルド時間の短縮。なぜなら、変更のあったファイルのみを再コンパイルするため、全てのファイルを再コンパイルする必要がなくなるから。
- オプション：
  - `-MMD`：ソースが #include したユーザーヘッダを列挙した .d を生成 (システムヘッダ除外でノイズ減)
  - `-MP`：.d に記録された各ヘッダへダミーターゲットを付与し、ヘッダ削除時の "No rule to make target" エラーを防止
  - `-MF <file>`：生成する依存ファイルの保存先・ファイル名を明示 (deps/ に格納したい場合など)

- 生成タイミング：各 .cpp をコンパイルして .o 生成時に同時に .d も出力
- 読み込み: -include $(DEPS) で存在すれば取り込み、初回 (未生成) は静かにスキップ

### | について

- ex01/Makefile の `|` は、「order-only prerequisite（順序のみ依存）」を区切る記号です。
- 書式: target: 通常依存 | 順序のみ依存
- 効果: | 右側のターゲットは先に用意されますが、タイムスタンプが更新されても target の再ビルド原因になりません。
- 用途: ディレクトリ作成など「存在は必要だが更新で再コンパイルさせたくない」もの（例: $(OBJDIR), $(DEPDIR)）。
- このMakefileでは、オブジェクトをビルドする前に obj/ と dep/ を作るが、ディレクトリの更新で .o を無駄に作り直さない、という意図です。
